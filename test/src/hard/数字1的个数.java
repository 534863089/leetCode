package hard;

public class 数字1的个数 {

    // > 2023/04/25 11:33:47
    // 运行失败:
    // 	Time Limit Exceeded
    // 	测试用例:824883294
    // 	stdout:
    public static int countDigitOne(int n) {
        int result = 0;
        for (int i = n; i >= 0; i--) {
            String sn = Integer.toString(i);
            for (int j = 0; j < sn.length(); j++) {
                if ('1' == sn.charAt(j)) {
                    result++;
                }
            }
        }
        return result;
    }

    // 经过上面两种血的教训，考虑我们肯定不能一个数一个数的去遍历，去找他们含有1的数量，那么，能不能一批一批地去找呢？
    // 比如，把所有的数一起来考虑，先找他们个位可能出现1的数量，再找十位可能出现1的数量？
    // 我们以n=2021为例，所有小于等于 2021 的数中个位一共会出现多少个 1 呢？
    // 我们可以很容易地发现，个位数出现1的频率是每10个数出现一次，对不对？
    // 所以，个位数出现多少 1 就取决于，一个有多少个 10，比如 2021 一共用 202 个 10，所以，个位出现 1 的数一共有 202 次（1， 11， 21，2011）+ 1次（2021）。
    // 为什么最后一个 1 次要单独拿出来计算呢？
    // 因为这个 1 次是比较特殊的，如果把 n 换成 2020 ，这样最后的 1 次是没有的，你要仔细考虑一下。
    // 只有 n 的个位数大于等于 1 的时候，才需要计算最后的这个 1 次。
    // 同理，我们考虑十位数一个有多少个 1。
    // 很简单，每 100 个数会出现 10 个十位数为 1 的数字，同样地，如果 n 的后面两位小于 10，则不用额外加次数，如果后两位大于等于 10，则需要额外加次数。
    // 比如，n=2021时，最后要加 10 次，n=2009时，最后不要加 10次，而n=2015时，最后要加 15-10+1=6次，这一块，你仔细体会一下。
    // 同样地道理，可以推断出千位数出现多少个 1，就很简单了，用公式统一表示为（n 表示题目指定的参数，i 为统计哪位上的1）：
    //
    // count = (n / (i * 10) * i) + ?，?处的数量就要看 i 及其右边的位数，即n % (i * 10)（记为 x），是小于 i 、大于等于 i 了，具体大多少了：
    //
    // x < i，? = 0
    // i <= x < 2 * i, ? = x - i + 1
    // x >= 2 * i，? = i
    // 写成一行：? = min(max(x - i + 1, 0), i)，请仔细体会。
    //
    // 完整公式为：count = (n / (i * 10) * i) + min(max(n % (i * 10) - i + 1, 0), i)。
    //
    // 有了公式，我们很快就能计算出来 n = 2021时，百位数一共会出现 2 * 100 + min(max(21-100+1, 0), 100)=200 个1了，它们分别是100,101,..,199,1100,1101,1199。
    //
    // > 2023/04/25 14:45:14
    // 解答成功:
    // 	执行耗时:0 ms,击败了100.00% 的Java用户
    // 	内存消耗:38.3 MB,击败了44.01% 的Java用户
    public static int countDigitOne2(int n) {
        int ans = 0;
        for (int i = 1; i <= n; i *= 10) {
            ans += (n / (i * 10)) * i + Math.min(Math.max(n % (i * 10) - i + 1, 0), i);
        }
        return ans;
    }


    public static void main(String[] args) {
        int n = 110;
        System.out.println(countDigitOne2(n));
        System.out.println(countDigitOne(n));
    }
}

// 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
//
// 示例 1：
//
// 输入：n = 13
// 输出：6
// 示例 2：
//
// 输入：n = 0
// 输出：0
// 提示：
//
// 0 <= n <= 10^9
// Related Topics
// 递归
// 数学
// 动态规划
